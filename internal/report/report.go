package report

import (
	"fmt"
	"time"

	"loot/internal/hash"
	"loot/internal/offload"

	"github.com/go-pdf/fpdf"
)

// GeneratePDF creates a PDF report for the offload operation
func GeneratePDF(path string, o *offload.Offloader, startTime, endTime time.Time) error {
	pdf := fpdf.New("P", "mm", "A4", "")
	pdf.AddPage()
	pdf.SetFont("Arial", "B", 16)
	pdf.Cell(40, 10, "LOOT - Offload Report")
	pdf.Ln(12)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, fmt.Sprintf("Date: %s", time.Now().Format(time.RFC1123)))
	pdf.Ln(10)

	// File Details
	pdf.SetFont("Arial", "B", 14)
	pdf.Cell(40, 10, "Job Details")
	pdf.Ln(8)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 8, fmt.Sprintf("Source:      %s", o.Source))
	pdf.Ln(6)
	for i, dst := range o.Destinations {
		pdf.Cell(40, 8, fmt.Sprintf("Dest %d:      %s", i+1, dst))
		pdf.Ln(6)
	}
	pdf.Ln(6)
	pdf.Cell(40, 8, fmt.Sprintf("Files:       %d", len(o.Files)))
	pdf.Ln(6)

	// Calculate total size from files list to be accurate
	var totalSize int64
	for _, f := range o.Files {
		totalSize += f.Size
	}
	pdf.Cell(40, 8, fmt.Sprintf("Total Size:  %s", offload.FormatBytes(uint64(totalSize))))
	pdf.Ln(8)

	// Transfer Stats
	duration := endTime.Sub(startTime)
	seconds := duration.Seconds()
	speedBps := float64(totalSize) / seconds

	pdf.SetFont("Arial", "B", 14)
	pdf.Cell(40, 10, "Transfer Statistics")
	pdf.Ln(8)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 8, fmt.Sprintf("Start Time: %s", startTime.Format("15:04:05")))
	pdf.Ln(6)
	pdf.Cell(40, 8, fmt.Sprintf("End Time:   %s", endTime.Format("15:04:05")))
	pdf.Ln(6)
	pdf.Cell(40, 8, fmt.Sprintf("Duration:   %v", duration.Round(time.Second)))
	pdf.Ln(6)
	pdf.Cell(40, 8, fmt.Sprintf("Avg Speed:  %s/s", offload.FormatBytes(uint64(speedBps))))
	pdf.Ln(8)

	// Verification
	pdf.SetFont("Arial", "B", 14)
	pdf.Cell(40, 10, "Verification (xxHash)")
	pdf.Ln(8)

	// Check if we have a single root hash (single file) or need to list files
	if o.SourceHash != (hash.HashResult{}) && o.SourceHash.String() != "" {
		// Single file or root hash available
		pdf.SetFont("Arial", "", 10)
		pdf.Cell(40, 10, fmt.Sprintf("Source Hash: %s", o.SourceHash))
		pdf.Ln(6)
		pdf.Cell(40, 10, fmt.Sprintf("Dest Hash:   %s", o.DestHash))
		pdf.Ln(8)

		if o.SourceHash == o.DestHash {
			pdf.SetFont("Arial", "B", 12)
			pdf.SetTextColor(0, 128, 0) // Green
			pdf.Cell(40, 10, "STATUS: VERIFIED MATCH")
		} else {
			pdf.SetFont("Arial", "B", 12)
			pdf.SetTextColor(255, 0, 0) // Red
			pdf.Cell(40, 10, "STATUS: CHECKSUM MISMATCH")
		}
	} else {
		// List files and their hashes
		pdf.SetFont("Arial", "B", 10)
		pdf.Cell(100, 8, "File")
		pdf.Cell(60, 8, "xxHash")
		pdf.Ln(8)

		pdf.SetFont("Arial", "", 9)
		for _, f := range o.Files {
			// Get relative path shortened
			relPath := f.RelPath
			if len(relPath) > 50 {
				relPath = "..." + relPath[len(relPath)-47:]
			}

			hashStr := f.Hash.String()
			// Assuming Hash is Source Hash. Destination check implied by successful copy phase?
			// Actually Offloader structure doesn't store per-file DestHash, only assumes verify passed if job succeeded?
			// But user wants to see the hash.

			pdf.Cell(100, 6, relPath)
			pdf.Cell(60, 6, hashStr)
			pdf.Ln(6)
		}

		pdf.Ln(6)
		if len(o.Files) > 0 {
			pdf.SetFont("Arial", "B", 12)
			pdf.SetTextColor(0, 128, 0) // Green
			pdf.Cell(40, 10, "STATUS: ALL FILES VERIFIED")
		}
	}
	pdf.SetTextColor(0, 0, 0) // Reset

	// footer
	pdf.SetY(-15)
	pdf.SetFont("Arial", "I", 8)
	pdf.Cell(0, 10, fmt.Sprintf("Generated by LOOT on %s", time.Now().Format("2006-01-02")))

	return pdf.OutputFileAndClose(path)
}
